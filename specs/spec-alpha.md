# Dunnes Voucher Bot - Alpha Spec

A Telegram-based voucher sharing system for Dunnes Stores Ireland. Users upload vouchers via Telegram, earn coins, and claim vouchers from other users.

**License**: AGPL-3.0

---

## Table of Contents

1. [Overview](#overview)
2. [Tech Stack](#tech-stack)
3. [Project Setup](#project-setup)
4. [File Structure](#file-structure)
5. [Convex Schema](#convex-schema)
6. [Coin Economy](#coin-economy)
7. [Convex Functions](#convex-functions)
8. [Telegram Integration](#telegram-integration)
9. [Gemini OCR Integration](#gemini-ocr-integration)
10. [Environment Variables](#environment-variables)
11. [Telegram Bot Setup](#telegram-bot-setup)
12. [Testing](#testing)
13. [Deployment](#deployment)
14. [Manual Admin Tasks](#manual-admin-tasks)
15. [Upgrade Path](#upgrade-path)

---

## Overview

### What This Alpha Includes
- **Invite-only signup** with trackable codes
- Upload voucher ‚Üí OCR extracts type/expiry ‚Üí earn coins
- Claim voucher ‚Üí receive image ‚Üí spend coins
- Report "already used" ‚Üí get replacement or refund
- Basic coin economy

### What's Deferred to Full MVP
- Obligation system (upload-after-claim requirement)
- Automated fraud detection/flagging
- Cron jobs (expiry, penalties, escalation)
- Uploader response flow ("lying"/"my bad")
- Admin dashboard

### User Flow

**First-time users (invite required):**
1. User clicks invite link: `https://t.me/DunnesVoucherBot?start=REDDIT50`
2. Telegram opens and user clicks "Start"
3. Bot validates code (passed via /start parameter) ‚Üí creates user ‚Üí sends welcome message

**Returning users:**
1. User sends voucher photo to Telegram bot
2. Bot uploads image to Convex storage
3. Gemini OCR extracts voucher type (‚Ç¨5/‚Ç¨10/‚Ç¨20) and expiry date
4. User earns coins based on voucher type
5. User can claim vouchers by sending "5", "10", or "20"
6. Bot sends voucher image to user, deducts coins
7. If voucher already used, user sends "report" to get replacement/refund

### Cost Estimates

**Gemini 2.0 Flash-Lite**: ~$0.00021/image (based on real-world testing)

| Scale | Monthly Cost |
|-------|--------------|
| 500 vouchers/day | ~‚Ç¨1/month (within Gemini free tier) |
| 1000 vouchers/day | ~‚Ç¨4/month |
| 2000 vouchers/day | ~‚Ç¨10/month |

Free tiers cover: Gemini (500/day free), Convex (free tier), Telegram (completely free)

### Build Estimate

**7-11 hours** (one weekend)

---

## Tech Stack

| Component | Technology |
|-----------|------------|
| Backend | Convex |
| Database | Convex (built-in) |
| File Storage | Convex Storage |
| OCR | Gemini 2.5 Flash-Lite |
| Messaging | Telegram Bot API |

---

## Project Setup



This creates a `convex/` directory and connects to Convex cloud.

### Step 6: Set Environment Variables

```bash
npx convex env set GEMINI_API_KEY "your-gemini-api-key"
npx convex env set TELEGRAM_BOT_TOKEN "your-telegram-bot-token"
```

### Step 7: Deploy

```bash
npx convex dev
```

---

## File Structure

```
dunnes-voucher-bot/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ convex/
‚îÇ   ‚îú‚îÄ‚îÄ _generated/           # Auto-generated by Convex
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.d.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dataModel.d.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ server.d.ts
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts             # Database schema
‚îÇ   ‚îú‚îÄ‚îÄ http.ts               # HTTP endpoints (Telegram webhook)
‚îÇ   ‚îú‚îÄ‚îÄ mutations/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.ts          # User mutations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vouchers.ts       # Voucher mutations
‚îÇ   ‚îú‚îÄ‚îÄ queries/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts          # All queries
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ocr.ts            # Gemini OCR processing
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ telegram.ts       # Telegram message handling
‚îÇ   ‚îî‚îÄ‚îÄ lib/
‚îÇ       ‚îî‚îÄ‚îÄ constants.ts      # Shared constants
```

---

## Convex Schema

Create `convex/schema.ts`:

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Invite codes table - for controlled signups
  inviteCodes: defineTable({
    // The invite code (e.g., "REDDIT50", "IRELAND-LAUNCH")
    code: v.string(),
    // Optional label for tracking (e.g., "r/ireland post", "Twitter launch")
    label: v.optional(v.string()),
    // Maximum number of signups allowed with this code
    maxUses: v.number(),
    // Current number of times this code has been used
    usedCount: v.number(),
    // Optional expiry timestamp (null = never expires)
    expiresAt: v.optional(v.number()),
    // Unix timestamp when code was created
    createdAt: v.number(),
  }).index("by_code", ["code"]),

  // Users table - stores Telegram users
  users: defineTable({
    // Telegram Chat ID (stringified)
    telegramChatId: v.string(),
    // Telegram Username (optional)
    username: v.optional(v.string()),
    // Telegram First Name
    firstName: v.optional(v.string()),
    // Current coin balance (0-100)
    coins: v.number(),
    // Whether user is banned from the service
    isBanned: v.boolean(),
    // Which invite code this user signed up with
    inviteCode: v.optional(v.string()),
    // Unix timestamp when user first messaged bot
    createdAt: v.number(),
    // Unix timestamp of last interaction
    lastActiveAt: v.number(),
  }).index("by_chat_id", ["telegramChatId"]),

  // Messages table - stores incoming Telegram messages
  messages: defineTable({
    // Telegram Message ID (unique per chat)
    telegramMessageId: v.number(),
    // Telegram Chat ID
    telegramChatId: v.string(),
    // Direction of message
    direction: v.union(v.literal("inbound"), v.literal("outbound")),
    // Type of message
    messageType: v.union(v.literal("text"), v.literal("image")),
    // Text content (or caption for images)
    text: v.optional(v.string()),
    // Convex storage ID if message contained an image
    imageStorageId: v.optional(v.id("_storage")),
    // Unix timestamp
    createdAt: v.number(),
  })
    .index("by_chat_id", ["telegramChatId"])
    .index("by_message_id", ["telegramChatId", "telegramMessageId"]),

  // Vouchers table - stores uploaded voucher images and metadata
  vouchers: defineTable({
    // Voucher denomination: "5" = ‚Ç¨5 off ‚Ç¨25, "10" = ‚Ç¨10 off ‚Ç¨50, "20" = ‚Ç¨20 off ‚Ç¨100
    type: v.union(v.literal("5"), v.literal("10"), v.literal("20")),
    // Current voucher status
    status: v.union(
      v.literal("processing"),  // OCR in progress
      v.literal("available"),   // Ready to be claimed
      v.literal("claimed"),     // Someone claimed it
      v.literal("reported"),    // Claimer reported it as already used
      v.literal("expired")      // Past expiry date (set manually or via future cron)
    ),
    // Reference to image in Convex storage
    imageStorageId: v.id("_storage"),
    // Barcode number extracted by OCR (optional, may not be readable)
    barcodeNumber: v.optional(v.string()),
    // Unix timestamp of voucher expiry date
    expiryDate: v.number(),
    // User who uploaded this voucher
    uploaderId: v.id("users"),
    // User who claimed this voucher (null if not claimed)
    claimerId: v.optional(v.id("users")),
    // Unix timestamp when voucher was claimed
    claimedAt: v.optional(v.number()),
    // Unix timestamp when voucher was uploaded
    createdAt: v.number(),
    // Raw JSON response from Gemini for debugging
    ocrRawResponse: v.optional(v.string()),
  })
    .index("by_status_type", ["status", "type"])
    .index("by_uploader", ["uploaderId"])
    .index("by_claimer_status", ["claimerId", "status"]),

  // Reports table - tracks "already used" reports
  reports: defineTable({
    // The voucher being reported
    voucherId: v.id("vouchers"),
    // User who reported the voucher (must be the claimer)
    reporterId: v.id("users"),
    // User who uploaded the voucher
    uploaderId: v.id("users"),
    // If a replacement was given, reference to the new voucher
    replacementVoucherId: v.optional(v.id("vouchers")),
    // Unix timestamp when report was created
    createdAt: v.number(),
  })
    .index("by_voucher", ["voucherId"])
    .index("by_uploader", ["uploaderId"]),

  // Transactions table - audit log of all coin changes
  transactions: defineTable({
    // User whose coins changed
    userId: v.id("users"),
    // Type of transaction
    type: v.union(
      v.literal("signup_bonus"),   // Initial 20 coins on first message
      v.literal("upload_reward"),  // Coins earned for uploading voucher
      v.literal("claim_spend"),    // Coins spent to claim voucher
      v.literal("report_refund")   // Coins refunded when voucher was already used
    ),
    // Amount of coins (positive for gains, negative for spends)
    amount: v.number(),
    // Related voucher (optional, not present for signup_bonus)
    voucherId: v.optional(v.id("vouchers")),
    // Unix timestamp
    createdAt: v.number(),
  }).index("by_user", ["userId"]),
});
```

---

## Coin Economy

### Coin Values

| Action | Coins | Notes |
|--------|-------|-------|
| Signup bonus | +20 | One-time on first message |
| Upload ‚Ç¨5 voucher | +15 | Highest reward (smallest voucher) |
| Upload ‚Ç¨10 voucher | +10 | Medium reward |
| Upload ‚Ç¨20 voucher | +5 | Lowest reward (largest voucher) |
| Claim ‚Ç¨5 voucher | -15 | Highest cost |
| Claim ‚Ç¨10 voucher | -10 | Medium cost |
| Claim ‚Ç¨20 voucher | -5 | Lowest cost |
| Report refund | +cost | Refund coins spent on bad voucher |

### Coin Limits

- **Maximum coins**: 100 (can't exceed this)
- **Minimum coins**: 0 (can't go negative)

### Design Rationale

Smaller vouchers (‚Ç¨5) cost more coins because:
1. They're easier to use (only ‚Ç¨25 spend required)
2. They expire more frequently (higher circulation)
3. Encourages users to upload more to earn coins

---

## Convex Functions

### Constants

Create `convex/lib/constants.ts`:

```typescript
// Coin rewards for uploading vouchers (by type)
export const UPLOAD_REWARDS: Record<string, number> = {
  "5": 15,   // ‚Ç¨5 voucher = 15 coins
  "10": 10,  // ‚Ç¨10 voucher = 10 coins
  "20": 5,   // ‚Ç¨20 voucher = 5 coins
};

// Coin costs for claiming vouchers (by type)
export const CLAIM_COSTS: Record<string, number> = {
  "5": 15,   // ‚Ç¨5 voucher = 15 coins
  "10": 10,  // ‚Ç¨10 voucher = 10 coins
  "20": 5,   // ‚Ç¨20 voucher = 5 coins
};

// Signup bonus
export const SIGNUP_BONUS = 20;

// Coin limits
export const MAX_COINS = 100;
export const MIN_COINS = 0;

// Valid voucher types
export const VOUCHER_TYPES = ["5", "10", "20"] as const;
export type VoucherType = (typeof VOUCHER_TYPES)[number];
```

### User Mutations

Create `convex/mutations/users.ts`:

```typescript
import { mutation, internalMutation } from "../_generated/server";
import { v } from "convex/values";
import { SIGNUP_BONUS } from "../lib/constants";

/**
 * Generate a short random code (6 chars, alphanumeric uppercase).
 */
function generateShortCode(): string {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let code = "";
  for (let i = 0; i < 6; i++) {
    code += chars[Math.floor(Math.random() * chars.length)];
  }
  return code;
}

/**
 * Create a new invite code.
 * If code is not provided, generates a random 6-char code.
 *
 * @param code - Optional custom code (e.g., "REDDIT50")
 * @param label - Optional label for tracking (e.g., "r/ireland launch post")
 * @param maxUses - Maximum signups allowed (default 50)
 * @param expiresInDays - Optional expiry in days from now
 * @returns The created invite code and Telegram link
 */
export const createInviteCode = mutation({
  args: {
    code: v.optional(v.string()),
    label: v.optional(v.string()),
    maxUses: v.optional(v.number()),
    expiresInDays: v.optional(v.number()),
  },
  handler: async (ctx, { code, label, maxUses = 50, expiresInDays }) => {
    const finalCode = code?.toUpperCase() || generateShortCode();

    const existing = await ctx.db
      .query("inviteCodes")
      .withIndex("by_code", (q) => q.eq("code", finalCode))
      .first();

    if (existing) {
      throw new Error(`Code "${finalCode}" already exists`);
    }

    const now = Date.now();
    const expiresAt = expiresInDays
      ? now + expiresInDays * 24 * 60 * 60 * 1000
      : undefined;

    await ctx.db.insert("inviteCodes", {
      code: finalCode,
      label,
      maxUses,
      usedCount: 0,
      expiresAt,
      createdAt: now,
    });

    const tgLink = `https://t.me/DunnesVoucherBot?start=${finalCode}`;

    return { code: finalCode, tgLink };
  },
});

/**
 * Create multiple single-use invite codes with the same label.
 * Returns codes as newline-separated text for easy copy/paste.
 *
 * @param count - Number of codes to generate
 * @param label - Label for tracking (e.g., "Reddit DMs batch 1")
 * @param expiresInDays - Optional expiry in days from now
 * @returns Object with codes array and codesText (newline-separated)
 */
export const createInviteCodeBatch = mutation({
  args: {
    count: v.number(),
    label: v.string(),
    expiresInDays: v.optional(v.number()),
  },
  handler: async (ctx, { count, label, expiresInDays }) => {
    if (count < 1 || count > 100) {
      throw new Error("Count must be between 1 and 100");
    }

    const now = Date.now();
    const expiresAt = expiresInDays
      ? now + expiresInDays * 24 * 60 * 60 * 1000
      : undefined;

    const codes: string[] = [];

    for (let i = 0; i < count; i++) {
      let code = generateShortCode();

      const existing = await ctx.db
        .query("inviteCodes")
        .withIndex("by_code", (q) => q.eq("code", code))
        .first();

      if (existing) {
        code = generateShortCode();
      }

      await ctx.db.insert("inviteCodes", {
        code,
        label,
        maxUses: 1,
        usedCount: 0,
        expiresAt,
        createdAt: now,
      });

      codes.push(code);
    }

    return {
      codes,
      codesText: codes.join("\n"),
      count: codes.length,
      label,
    };
  },
});

/**
 * Validate an invite code and increment usage if valid.
 * Internal mutation - only called from actions.
 *
 * @param code - The invite code to validate
 * @returns { valid: true } or { valid: false, reason: string }
 */
export const validateAndUseInviteCode = internalMutation({
  args: { code: v.string() },
  handler: async (ctx, { code }) => {
    const inviteCode = await ctx.db
      .query("inviteCodes")
      .withIndex("by_code", (q) => q.eq("code", code.toUpperCase()))
      .first();

    if (!inviteCode) {
      return { valid: false, reason: "Invalid invite code" };
    }

    if (inviteCode.usedCount >= inviteCode.maxUses) {
      return { valid: false, reason: "This invite code has reached its limit" };
    }

    if (inviteCode.expiresAt && inviteCode.expiresAt < Date.now()) {
      return { valid: false, reason: "This invite code has expired" };
    }

    await ctx.db.patch(inviteCode._id, {
      usedCount: inviteCode.usedCount + 1,
    });

    return { valid: true };
  },
});

/**
 * Check if a user exists by Telegram Chat ID (without creating user).
 * Internal mutation - used to check if user needs invite code.
 *
 * @param telegramChatId - Telegram Chat ID
 * @returns User data if exists, null otherwise
 */
export const getUserByTelegramChatId = internalMutation({
  args: { telegramChatId: v.string() },
  handler: async (ctx, { telegramChatId }) => {
    const existing = await ctx.db
      .query("users")
      .withIndex("by_chat_id", (q) => q.eq("telegramChatId", telegramChatId))
      .first();

    if (existing) {
      await ctx.db.patch(existing._id, { lastActiveAt: Date.now() });
      return {
        _id: existing._id,
        coins: existing.coins,
        isBanned: existing.isBanned,
      };
    }

    return null;
  },
});

/**
 * Create a new user with a validated invite code.
 * Internal mutation - only called after invite code is validated.
 *
 * @param telegramChatId - Telegram Chat ID
 * @param username - Telegram Username (optional)
 * @param firstName - Telegram First Name (optional)
 * @param inviteCode - The invite code used to sign up
 * @returns User data
 */
export const createUserWithInvite = internalMutation({
  args: {
    telegramChatId: v.string(),
    username: v.optional(v.string()),
    firstName: v.optional(v.string()),
    inviteCode: v.string(),
  },
  handler: async (ctx, { telegramChatId, username, firstName, inviteCode }) => {
    const existing = await ctx.db
      .query("users")
      .withIndex("by_chat_id", (q) => q.eq("telegramChatId", telegramChatId))
      .first();

    if (existing) {
      return {
        _id: existing._id,
        coins: existing.coins,
        isBanned: existing.isBanned,
      };
    }

    const now = Date.now();
    const userId = await ctx.db.insert("users", {
      telegramChatId,
      username,
      firstName,
      coins: SIGNUP_BONUS,
      isBanned: false,
      inviteCode: inviteCode.toUpperCase(),
      createdAt: now,
      lastActiveAt: now,
    });

    await ctx.db.insert("transactions", {
      userId,
      type: "signup_bonus",
      amount: SIGNUP_BONUS,
      createdAt: now,
    });

    return {
      _id: userId,
      coins: SIGNUP_BONUS,
      isBanned: false,
    };
  },
});

/**
 * Store a new message in the messages table.
 * Returns null if message already exists (deduplication).
 * Internal mutation.
 */
export const storeMessage = internalMutation({
  args: {
    telegramMessageId: v.number(),
    telegramChatId: v.string(),
    direction: v.union(v.literal("inbound"), v.literal("outbound")),
    messageType: v.union(v.literal("text"), v.literal("image")),
    text: v.optional(v.string()),
    imageStorageId: v.optional(v.id("_storage")),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db
      .query("messages")
      .withIndex("by_message_id", (q) =>
        q
          .eq("telegramChatId", args.telegramChatId)
          .eq("telegramMessageId", args.telegramMessageId)
      )
      .first();

    if (existing) {
      return null;
    }

    return await ctx.db.insert("messages", {
      ...args,
      createdAt: Date.now(),
    });
  },
});

/**
 * Update a message with the image storage ID after upload.
 * Internal mutation.
 */
export const patchMessageImage = internalMutation({
  args: {
    messageId: v.id("messages"),
    imageStorageId: v.id("_storage"),
  },
  handler: async (ctx, { messageId, imageStorageId }) => {
    await ctx.db.patch(messageId, { imageStorageId });
  },
});
```

### Voucher Mutations

(No major changes needed for Telegram, just ensure `userId` logic remains consistent)

### Queries

Create `convex/queries/index.ts` (update `getUserByPhone` to `getUserByTelegramChatId`):

```typescript
import { query, internalQuery } from "../_generated/server";
import { v } from "convex/values";

/**
 * Get user by Telegram Chat ID.
 *
 * @param telegramChatId - Telegram Chat ID
 * @returns User document or null
 */
export const getUserByTelegramChatId = query({
  args: { telegramChatId: v.string() },
  handler: async (ctx, { telegramChatId }) => {
    return await ctx.db
      .query("users")
      .withIndex("by_chat_id", (q) => q.eq("telegramChatId", telegramChatId))
      .first();
  },
});

// ... other queries remain the same
```

---

## Telegram Integration

### HTTP Router

Create `convex/http.ts`:

```typescript
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";
import { internal } from "./_generated/api";

const http = httpRouter();

/**
 * Telegram webhook message handler.
 * Telegram sends all incoming messages here.
 */
http.route({
  path: "/telegram/webhook",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    try {
      const body = await request.json();

      // Log incoming webhook for debugging
      console.log("Webhook received:", JSON.stringify(body, null, 2));

      // Process message in background action
      // We only care about "message" updates for now
      if (body.message) {
        await ctx.runAction(internal.actions.telegram.handleTelegramMessage, {
          message: body.message,
        });
      }

      return new Response("OK", { status: 200 });
    } catch (error) {
      console.error("Webhook error:", error);
      // Still return 200 to prevent retries
      return new Response("OK", { status: 200 });
    }
  }),
});

export default http;
```

### Telegram Action

Create `convex/actions/telegram.ts`:

```typescript
import { internalAction } from "../_generated/server";
import { v } from "convex/values";
import { internal } from "../_generated/api";
import { CLAIM_COSTS, VOUCHER_TYPES } from "../lib/constants";

/**
 * Handle incoming Telegram message.
 */
export const handleTelegramMessage = internalAction({
  args: {
    message: v.any(),
  },
  handler: async (ctx, { message }) => {
    const chatId = String(message.chat.id);
    const messageId = message.message_id;
    const text = message.text || message.caption || "";
    const username = message.from.username;
    const firstName = message.from.first_name;
    const isImage = !!message.photo;

    // 1. Idempotency Check & Storage
    // Store message immediately. If it exists, this returns null.
    const messageDbId = await ctx.runMutation(internal.mutations.users.storeMessage, {
      telegramMessageId: messageId,
      telegramChatId: chatId,
      direction: "inbound",
      messageType: isImage ? "image" : "text",
      text: text,
      // For images, we'll patch this later
      imageStorageId: undefined,
    });

    if (!messageDbId) {
      console.log(`Duplicate message ${messageId} from ${chatId}, ignoring.`);
      return;
    }

    // 2. Get User
    const user = await ctx.runMutation(internal.mutations.users.getUserByTelegramChatId, {
      telegramChatId: chatId,
    });

    // 3. Handle New User (Invite Code)
    if (!user) {
      // Expecting /start CODE
      if (text.startsWith("/start")) {
        const code = text.split(" ")[1];
        if (code) {
           const result = await ctx.runMutation(internal.mutations.users.validateAndUseInviteCode, { code });
           if (result.valid) {
             const newUser = await ctx.runMutation(internal.mutations.users.createUserWithInvite, {
               telegramChatId: chatId,
               username,
               firstName,
               inviteCode: code
             });
             await sendTelegramMessage(chatId, `üéâ Welcome to Dunnes Voucher Bot!\n\nYou've been given ${newUser.coins} coins to start.`);
             return;
           } else {
             await sendTelegramMessage(chatId, `‚ùå ${result.reason}`);
             return;
           }
        }
      }
      await sendTelegramMessage(chatId, "üëã Welcome! You need an invite link to join.");
      return;
    }

    if (user.isBanned) {
      return;
    }

    // 4. Handle Image (Voucher Upload)
    if (isImage) {
      // Telegram sends multiple sizes, take the largest (last one)
      const photo = message.photo[message.photo.length - 1];
      const fileId = photo.file_id;

      try {
        const imageUrl = await getTelegramFileUrl(fileId);
        const imageBlob = await fetch(imageUrl).then(r => r.blob());
        const storageId = await ctx.storage.store(imageBlob);

        // Update message with storage ID
        await ctx.runMutation(internal.mutations.users.patchMessageImage, {
            messageId: messageDbId,
            imageStorageId: storageId
        });

        await ctx.runMutation(internal.mutations.vouchers.uploadVoucher, {
          userId: user._id,
          imageStorageId: storageId,
        });

        await sendTelegramMessage(chatId, "üì∏ Processing your voucher...");
      } catch (e) {
        console.error(e);
        await sendTelegramMessage(chatId, "‚ùå Failed to process image.");
      }
      return;
    }

    // 5. Handle Commands
    const lowerText = text.toLowerCase();

    if (lowerText === "/balance" || lowerText === "balance") {
      await sendTelegramMessage(chatId, `üí∞ You have ${user.coins} coins.`);
    } else if (lowerText === "/help" || lowerText === "help") {
      await sendTelegramMessage(chatId, `Commands:\nüì∏ Send photo to upload\nüí≥ "claim 5/10/20"\nüí∞ /balance`);
    } else if (lowerText.startsWith("claim")) {
       const type = lowerText.match(/(\d+)/)?.[1];
       if (type && VOUCHER_TYPES.includes(type as any)) {
         try {
           const voucher = await ctx.runMutation(internal.mutations.vouchers.claimVoucher, {
             userId: user._id,
             voucherType: type as any
           });
           const imageUrl = await ctx.storage.getUrl(voucher.imageStorageId);
           await sendTelegramPhoto(chatId, imageUrl!, `Here is your ‚Ç¨${type} voucher!`);
         } catch (e: any) {
           await sendTelegramMessage(chatId, `‚ùå ${e.message}`);
         }
       }
    }
  },
});

async function sendTelegramMessage(chatId: string, text: string) {
  const token = process.env.TELEGRAM_BOT_TOKEN;
  await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ chat_id: chatId, text }),
  });
}

async function sendTelegramPhoto(chatId: string, photoUrl: string, caption: string) {
  const token = process.env.TELEGRAM_BOT_TOKEN;
  await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ chat_id: chatId, photo: photoUrl, caption }),
  });
}

async function getTelegramFileUrl(fileId: string): Promise<string> {
  const token = process.env.TELEGRAM_BOT_TOKEN;
  const res = await fetch(`https://api.telegram.org/bot${token}/getFile?file_id=${fileId}`);
  const data = await res.json();
  return `https://api.telegram.org/file/bot${token}/${data.result.file_path}`;
}
```

---

## Environment Variables

### Required Variables

| Variable | Description | How to Get |
|----------|-------------|------------|
| `GEMINI_API_KEY` | Google AI API key | [Google AI Studio](https://aistudio.google.com/app/apikey) |
| `TELEGRAM_BOT_TOKEN` | Telegram Bot Token | Message @BotFather on Telegram |

---

## Telegram Bot Setup

1. Open Telegram and search for **@BotFather**.
2. Send `/newbot` and follow the instructions to name your bot.
3. Copy the **API Token** provided.
4. Set the token in Convex: `npx convex env set TELEGRAM_BOT_TOKEN "your-token"`
5. Set the webhook URL:
   ```bash
   curl -F "url=https://your-convex-site.convex.site/telegram/webhook" https://api.telegram.org/bot<YOUR_TOKEN>/setWebhook
   ```

---

# Check deployment status
npx convex dashboard
```

### Production Checklist

- [ ] All environment variables set in production
- [ ] Telegram Bot Token configured
- [ ] Webhook URL points to production Convex
- [ ] Test message flow end-to-end

---

## Manual Admin Tasks

Since there's no admin dashboard in alpha, use Convex Dashboard directly:

### Create Invite Codes

1. Open Convex Dashboard
2. Go to "Functions" tab
3. Run `createInviteCode` mutation with:

```typescript
// Custom code for Reddit post
createInviteCode({
  code: "REDDIT50",
  label: "r/ireland launch post",
  maxUses: 50
})

// Auto-generated code
createInviteCode({
  label: "Twitter DMs",
  maxUses: 20,
  expiresInDays: 7
})
```

4. Copy the invite code to share. Users must manually send "code CODE" to the bot.

### Create Batch of Single-Use Codes (for DMs)

1. Run `createInviteCodeBatch` mutation:

```typescript
createInviteCodeBatch({
  count: 20,
  label: "Reddit DMs Dec 2024",
  expiresInDays: 14
})
```

2. Copy `codesText` from response - ready to paste:
```
3JHNE3
90HTE6
3OSUEF
LIE83V
...
```

3. DM each person a unique code

### View Invite Code Stats

1. Go to "Data" ‚Üí "inviteCodes" table
2. See `usedCount` vs `maxUses` for each code
3. Track which codes are driving signups

### Ban a User

1. Open Convex Dashboard
2. Go to "Data" ‚Üí "users" table
3. Find user by Telegram Chat ID
4. Click to edit
5. Set `isBanned: true`
6. Save

### View Reports

1. Go to "Data" ‚Üí "reports" table
2. See all reports with voucher IDs and user IDs
3. Cross-reference with "vouchers" and "users" tables

### Check for Fraud

1. Go to "Data" ‚Üí "reports" table
2. Group by `uploaderId` to see repeat offenders
3. Users with 3+ reports should be reviewed

### View Voucher Details

1. Go to "Data" ‚Üí "vouchers" table
2. Filter by status: "available", "claimed", "reported"
3. Check `ocrRawResponse` for OCR debug info

### Run Queries in Dashboard

The Convex Dashboard has a "Functions" tab where you can run queries directly:

```typescript
// Get all reports against a specific user
getReportsAgainstUser({ uploaderId: "user-id-here" })

// Get user's coin balance
getUser({ userId: "user-id-here" })
```

---

## Upgrade Path

When ready to upgrade from alpha to full MVP:

### 1. Add Obligations Table

Add to `schema.ts`:

```typescript
obligations: defineTable({
  userId: v.id("users"),
  voucherType: v.union(v.literal("5"), v.literal("10"), v.literal("20")),
  dueAt: v.number(),
  status: v.union(
    v.literal("pending"),
    v.literal("fulfilled"),
    v.literal("failed")
  ),
  claimVoucherId: v.id("vouchers"),
  fulfillmentVoucherId: v.optional(v.id("vouchers")),
  createdAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_status", ["status"])
  .index("by_due", ["dueAt"]),
```

### 2. Add Fraud Detection Fields

Add to users table:

```typescript
isFlagged: v.boolean(),
flaggedAt: v.optional(v.number()),
strikeCount: v.number(),
```

### 3. Add Report Status Fields

Add to reports table:

```typescript
status: v.union(
  v.literal("pending"),
  v.literal("resolved_lying"),
  v.literal("resolved_mybad")
),
uploaderResponseAt: v.optional(v.number()),
uploaderResponse: v.optional(v.union(v.literal("lying"), v.literal("mybad"))),
escalatedAt: v.optional(v.number()),
```

### 4. Add Cron Jobs

Create `convex/crons.ts`:

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Check for failed obligations daily at midnight
crons.daily(
  "check obligations",
  { hourUTC: 0, minuteUTC: 0 },
  internal.crons.checkFailedObligations
);

// Auto-escalate unresolved reports after 24h
crons.hourly(
  "escalate reports",
  { minuteUTC: 0 },
  internal.crons.escalateUnresolvedReports
);

export default crons;
```

### 5. Build Admin Dashboard

Use TanStack Start or Next.js with Convex React client to build dashboard with:

- User list with search/filter
- Ban/unban functionality
- Report review queue
- Voucher browser with OCR metadata
- Analytics (uploads/claims per day)

---

## Quick Reference

### Invite Format

Share your bot's link (e.g., `t.me/YourBotName`).
Users must send: `code <INVITE_CODE>`

### Commands Users Can Send

| Command | Action |
|---------|--------|
| code XXX | Sign up (new users only) |
| [Photo] | Upload voucher |
| help / ? / h | Show commands |
| balance / coins / b | Check coin balance |
| available / a | See voucher counts |
| claim 5 | Claim ‚Ç¨5 voucher |
| claim 10 | Claim ‚Ç¨10 voucher |
| claim 20 | Claim ‚Ç¨20 voucher |
| report / r | Report last voucher |

### Coin Values Quick Reference

| Voucher | Upload Reward | Claim Cost |
|---------|---------------|------------|
| ‚Ç¨5 | +15 coins | -15 coins |
| ‚Ç¨10 | +10 coins | -10 coins |
| ‚Ç¨20 | +5 coins | -5 coins |

### File Locations

| File | Purpose |
|------|---------|
| `convex/schema.ts` | Database schema |
| `convex/http.ts` | Telegram webhook |
| `convex/mutations/users.ts` | User mutations |
| `convex/mutations/vouchers.ts` | Voucher mutations |
| `convex/queries/index.ts` | All queries |
| `convex/telegram.ts` | Telegram handler |
| `convex/actions/ocr.ts` | Gemini OCR |
| `convex/lib/constants.ts` | Shared constants |

---

## License

**AGPL-3.0** - This software must remain open source. Any modifications or services built on this code must also be released under AGPL-3.0.
